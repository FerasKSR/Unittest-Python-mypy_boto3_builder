from _typeshed import Incomplete

class RequestExceededException(Exception):
    requested_amt: Incomplete
    retry_time: Incomplete
    def __init__(self, requested_amt, retry_time) -> None: ...

class RequestToken: ...

class TimeUtils:
    def time(self): ...
    def sleep(self, value): ...

class BandwidthLimiter:
    def __init__(self, leaky_bucket, time_utils: Incomplete | None = ...) -> None: ...
    def get_bandwith_limited_stream(self, fileobj, transfer_coordinator, enabled: bool = ...): ...

class BandwidthLimitedStream:
    def __init__(self, fileobj, leaky_bucket, transfer_coordinator, time_utils: Incomplete | None = ..., bytes_threshold=...) -> None: ...
    def enable_bandwidth_limiting(self) -> None: ...
    def disable_bandwidth_limiting(self) -> None: ...
    def read(self, amount): ...
    def signal_transferring(self) -> None: ...
    def signal_not_transferring(self) -> None: ...
    def seek(self, where, whence: int = ...) -> None: ...
    def tell(self): ...
    def close(self) -> None: ...
    def __enter__(self): ...
    def __exit__(self, *args, **kwargs) -> None: ...

class LeakyBucket:
    def __init__(self, max_rate, time_utils: Incomplete | None = ..., rate_tracker: Incomplete | None = ..., consumption_scheduler: Incomplete | None = ...) -> None: ...
    def consume(self, amt, request_token): ...

class ConsumptionScheduler:
    def __init__(self) -> None: ...
    def is_scheduled(self, token): ...
    def schedule_consumption(self, amt, token, time_to_consume): ...
    def process_scheduled_consumption(self, token) -> None: ...

class BandwidthRateTracker:
    def __init__(self, alpha: float = ...) -> None: ...
    @property
    def current_rate(self): ...
    def get_projected_rate(self, amt, time_at_consumption): ...
    def record_consumption_rate(self, amt, time_at_consumption) -> None: ...
