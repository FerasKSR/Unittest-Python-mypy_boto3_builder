import logging

from _typeshed import Incomplete
from s3transfer.compat import seekable as seekable
from s3transfer.exceptions import RetriesExceededError as RetriesExceededError
from s3transfer.futures import IN_MEMORY_DOWNLOAD_TAG as IN_MEMORY_DOWNLOAD_TAG
from s3transfer.tasks import SubmissionTask as SubmissionTask
from s3transfer.tasks import Task as Task
from s3transfer.utils import S3_RETRYABLE_DOWNLOAD_ERRORS as S3_RETRYABLE_DOWNLOAD_ERRORS
from s3transfer.utils import CountCallbackInvoker as CountCallbackInvoker
from s3transfer.utils import DeferredOpenFile as DeferredOpenFile
from s3transfer.utils import FunctionContainer as FunctionContainer
from s3transfer.utils import StreamReaderProgress as StreamReaderProgress
from s3transfer.utils import calculate_num_parts as calculate_num_parts
from s3transfer.utils import calculate_range_parameter as calculate_range_parameter
from s3transfer.utils import get_callbacks as get_callbacks
from s3transfer.utils import invoke_progress_callbacks as invoke_progress_callbacks

logger: logging.Logger

class DownloadOutputManager:
    def __init__(self, osutil, transfer_coordinator, io_executor) -> None: ...
    @classmethod
    def is_compatible(cls, download_target, osutil) -> None: ...
    def get_download_task_tag(self) -> None: ...
    def get_fileobj_for_io_writes(self, transfer_future) -> None: ...
    def queue_file_io_task(self, fileobj, data, offset) -> None: ...
    def get_io_write_task(self, fileobj, data, offset): ...
    def get_final_io_task(self) -> None: ...

class DownloadFilenameOutputManager(DownloadOutputManager):
    def __init__(self, osutil, transfer_coordinator, io_executor) -> None: ...
    @classmethod
    def is_compatible(cls, download_target, osutil): ...
    def get_fileobj_for_io_writes(self, transfer_future): ...
    def get_final_io_task(self): ...

class DownloadSeekableOutputManager(DownloadOutputManager):
    @classmethod
    def is_compatible(cls, download_target, osutil): ...
    def get_fileobj_for_io_writes(self, transfer_future): ...
    def get_final_io_task(self): ...

class DownloadNonSeekableOutputManager(DownloadOutputManager):
    def __init__(
        self, osutil, transfer_coordinator, io_executor, defer_queue: Incomplete | None = ...
    ) -> None: ...
    @classmethod
    def is_compatible(cls, download_target, osutil): ...
    def get_download_task_tag(self): ...
    def get_fileobj_for_io_writes(self, transfer_future): ...
    def get_final_io_task(self): ...
    def queue_file_io_task(self, fileobj, data, offset) -> None: ...
    def get_io_write_task(self, fileobj, data, offset): ...

class DownloadSpecialFilenameOutputManager(DownloadNonSeekableOutputManager):
    def __init__(
        self, osutil, transfer_coordinator, io_executor, defer_queue: Incomplete | None = ...
    ) -> None: ...
    @classmethod
    def is_compatible(cls, download_target, osutil): ...
    def get_fileobj_for_io_writes(self, transfer_future): ...
    def get_final_io_task(self): ...

class DownloadSubmissionTask(SubmissionTask): ...
class GetObjectTask(Task): ...
class ImmediatelyWriteIOGetObjectTask(GetObjectTask): ...
class IOWriteTask(Task): ...
class IOStreamingWriteTask(Task): ...
class IORenameFileTask(Task): ...
class IOCloseTask(Task): ...

class CompleteDownloadNOOPTask(Task):
    def __init__(
        self,
        transfer_coordinator,
        main_kwargs: Incomplete | None = ...,
        pending_main_kwargs: Incomplete | None = ...,
        done_callbacks: Incomplete | None = ...,
        is_final: bool = ...,
    ) -> None: ...

class DownloadChunkIterator:
    def __init__(self, body, chunksize) -> None: ...
    def __iter__(self): ...
    def __next__(self): ...
    next: Incomplete

class DeferQueue:
    def __init__(self) -> None: ...
    def request_writes(self, offset, data): ...
